==> test/AllSeqTypes.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with parameters of all basic types.
  Options(opt-arg sep :|=|spc):
  -h, --help                                 print this help (generated by
                                             cligen)
  --help-syntax                              advanced opts: prepend, multi-val,
                                             ...
  -b=, --bl=     array(bool)     EMPTY       append 1 val to bl
  -B=, --Bl=     array(bool)     false,true  append 1 val to Bl
  -s=, --s=      array(string)   EMPTY       append 1 val to s
  -S=, --S=      array(string)   ho,hey      append 1 val to S
  -i=, --i=      array(int)      EMPTY       append 1 val to i
  -I=, --I=      array(int)      1,2         append 1 val to I
  --i1=          array(int8)     EMPTY       append 1 val to i1
  --I1=          array(int8)     3,4         append 1 val to I1
  --i2=          array(int16)    EMPTY       append 1 val to i2
  --I2=          array(int16)    5,6         append 1 val to I2
  --i4=          array(int32)    EMPTY       append 1 val to i4
  --I4=          array(int32)    7,8         append 1 val to I4
  --i8=          array(int64)    EMPTY       append 1 val to i8
  --I8=          array(int64)    9,10        append 1 val to I8
  -u=, --u=      array(uint)     EMPTY       append 1 val to u
  -U=, --U=      array(uint)     11,12       append 1 val to U
  --u1=          array(uint8)    EMPTY       append 1 val to u1
  --U1=          array(uint8)    13,14       append 1 val to U1
  --u2=          array(uint16)   EMPTY       append 1 val to u2
  --U2=          array(uint16)   15,16       append 1 val to U2
  --u4=          array(uint32)   EMPTY       append 1 val to u4
  --U4=          array(uint32)   17,18       append 1 val to U4
  --u8=          array(uint64)   EMPTY       append 1 val to u8
  --U8=          array(uint64)   19,20       append 1 val to U8
  -f=, --f4=     array(float32)  EMPTY       append 1 val to f4
  -F=, --F4=     array(float32)  23.0,24.0   append 1 val to F4
  --f8=          array(float)    EMPTY       append 1 val to f8
  --F8=          array(float)    25.0,26.0   append 1 val to F8

==> test/AllSetTypes.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with parameters of all basic types.
  Options(opt-arg sep :|=|spc):
  -h, --help                                  print this help (generated by
                                              cligen)
  --help-syntax                               advanced opts: prepend, multi-val,
                                              ...
  -b=, --bl=     set(bool)    EMPTY           setbl
  -B=, --Bl=     set(bool)    false,true      setBl
  -i=, --i1=     set(int8)    EMPTY           seti1
  -I=, --I1=     set(int8)    3,4             setI1
  --i2=          set(int16)   EMPTY           seti2
  --I2=          set(int16)   5,6             setI2
  -u=, --u1=     set(uint8)   EMPTY           setu1
  -U=, --U1=     set(uint8)   13,14           setU1
  --u2=          set(uint16)  EMPTY           setu2
  --U2=          set(uint16)  15,16           setU2
  -e=, --e=      set(Color)   EMPTY           sete
  -E=, --E=      set(Color)   red,green,blue  setE

==> test/AllTypes.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with parameters of all basic types.
  Options(opt-arg sep :|=|spc):
  -?, --help                     print this help (generated by cligen)
  --help-syntax                  advanced opts: prepend, multi-val, ...
  -a, --aa       bool     false  setaa
  -b=, --bb=     string   "hi"   setbb
  -c=, --cc=     string   "ho"   setcc
  -d=, --dd=     char     'X'    setdd
  -e=, --ee=     int      1      setee
  -f=, --ff=     int8     2      setff
  -g=, --gg=     int16    3      setgg
  -h=, --hh=     int32    4      sethh
  -i=, --ii=     int64    5      setii
  -j=, --jj=     uint     6      setjj
  -k=, --kk=     uint8    7      setkk
  -l=, --ll=     uint16   8      setll
  -m=, --mm=     uint32   9      setmm
  -n=, --nn=     uint64   10     setnn
  -o=, --oo=     float    11.0   setoo
  -p=, --pp=     float32  12.0   setpp
  -q=, --qq=     float    13.0   setqq

==> test/BlockedShort.out <==
Usage:
  demo [optional-params] 
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  --alpha=       int     1      setalpha
  --abc=         float   2.0    setabc
  -a, --aaah     bool    false  setaaah
  --aloha=       string  ""     setaloha

==> test/CaseDistinguised.out <==
CaseDistinguised.nim(11, 3) Error: undeclared identifier: 'argCvtOptions'

==> test/CustomCmdName.out <==
Usage:
  deeeemo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     1      setalpha
  -b=, --beta=   float   2.0    setbeta
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/CustomType.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int   1        setalpha
  -v, --verb     bool  false    setverb
  -s=, --stuff=  CSV   "ab,cd"  append 1 val to stuff

==> test/DetectSet.out <==
Usage:
  foo [optional-params] 
  Options(opt-arg sep :|=|spc):
  -h, --help             print this help (generated by cligen)
  --help-syntax          advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int  1  setalpha
  -b=, --beta=   int  2  setbeta

==> test/DistinctInt.out <==
Usage:
  main [required&optional-params] 
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --age=    int  REQUIRED  setage

==> test/DupShort.out <==
Usage:
  demo [optional-params] 
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -z=, --alpha=  int     1      setalpha
  -a=, --abc=    float   2.0    setabc
  --aaah         bool    false  setaaah
  --aloha=       string  ""     setaloha

==> test/EarlySeq.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     1      setalpha
  -b=, --beta=   float   2.0    setbeta
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/EchoResult.out <==
Usage:
  editDistanceAscii [required&optional-params] 
Returns the edit distance between `a` and `b`.

This uses the `Levenshtein`:idx: distance algorithm with only a linear
memory overhead.
  Options(opt-arg sep :|=|spc):
  -h, --help                       print this help (generated by cligen)
  --help-syntax                    advanced opts: prepend, multi-val, ...
  -a=, --a=      string  REQUIRED  seta
  -b=, --b=      string  REQUIRED  setb

==> test/Enums.out <==
Usage:
  demo [required&optional-params] [args: string...]
demo entry point with varied, meaningless parameters.
  Options(opt-arg sep :|=|spc):
  -h, --help                             print this help (generated by cligen)
  --help-syntax                          advanced opts: prepend, multi-val, ...
  -c=, --c=      enum          REQUIRED  primary color
  -b=, --bg=     enum          red       background color
  -f=, --fg=     array(Color)  green     foreround colors
  --curs=        set(Color)    blue      cursor colors
  -x=, --x=      int           0         setx

==> test/External.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     1      setalpha
  -b=, --beta=   float   2.0    setbeta
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/FancyRepeats.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                           print this help (generated by cligen)
  --help-syntax                        advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int            1      setalpha
  -v=, --verb=   countr         0      setverb
  -j=, --junk=   array(string)  rs,tu  append 1 val to junk
  -s=, --stuff=  array(string)  ab,cd  append 1 val to stuff

==> test/FullyAutoMulti.out <==
Usage:
  FullyAutoMulti {subcommand}
where {subcommand} is one of:
  help demo print whoa nelly
Run top-level cmd with -h, --help or --help-syntax for top-level help.
Run top-level with subcmd "help" to get *all* helps.
Run any given subcommand with --help to see help for that one.
Top-level --version also available

==> test/FullyAutoMultiTopLvl.out <==
This is a multiple-dispatch command.  Top-level --help/--help-syntax
is also available.  Usage is like:
    FullyAutoMulti subcommand [subcommand-opts & args]
where subcommand syntaxes are as follows:

  demo [optional-params] [files: string...]
    demo entry point with varied, meaningless parameters.
    Options(opt-arg sep :|=|spc):
      -h, --help                    print this help (generated by cligen)
      --help-syntax                 advanced opts: prepend, multi-val, ...
      -a=, --alpha=  int     1      setalpha
      -b=, --beta=   float   2.0    setbeta
      -v, --verb     bool    false  on=chatty, off=quiet
      -i=, --item=   string  ""     setitem
  
  print [optional-params] [paths: string...]
    show entry point with varied, meaningless parameters.
    Options(opt-arg sep :|=|spc):
      -h, --help                   print this help (generated by cligen)
      --help-syntax                advanced opts: prepend, multi-val, ...
      -z=, --gamma=  int    1      setgamma
      -i=, --iota=   float  2.0    setiota
      -v, --verb     bool   false  setverb
  
  whoa [optional-params] [names: string...]
    Another entry point; here we echoResult
    Options(opt-arg sep :|=|spc):
      -h, --help                   print this help (generated by cligen)
      --help-syntax                advanced opts: prepend, multi-val, ...
      -z=, --zeta=   int    1      setzeta
      -e=, --eta=    float  2.0    seteta
      -v, --verb     bool   false  setverb
  
  nelly [optional-params] [names: string...]
    Yet another entry point; here we block autoEcho
    Options(opt-arg sep :|=|spc):
      -h, --help                  print this help (generated by cligen)
      --help-syntax               advanced opts: prepend, multi-val, ...
      --hooves=      int   4      sethooves
      -r=, --races=  int   9      setraces
      -v, --verb     bool  false  setverb

==> test/HashSets.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with parameters of all basic types.
  Options(opt-arg sep :|=|spc):
  -h, --help                                      print this help (generated by
                                                  cligen)
  --help-syntax                                   advanced opts: prepend,
                                                  multi-val, ...
  -i=, --i1=     hashset(int8)    EMPTY           seti1
  -I=, --I1=     hashset(int8)    3,4             setI1
  --i2=          hashset(int16)   EMPTY           seti2
  --I2=          hashset(int16)   5,6             setI2
  -u=, --u1=     hashset(uint8)   EMPTY           setu1
  -U=, --U1=     hashset(uint8)   13,14           setU1
  --u2=          hashset(uint16)  EMPTY           setu2
  --U2=          hashset(uint16)  16,15           setU2
  -e=, --e=      hashset(Color)   EMPTY           sete
  -E=, --E=      hashset(Color)   red,green,blue  setE

==> test/HelpTabCols.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help     print this help (generated by cligen)   
  --help-syntax  advanced opts: prepend, multi-val, ...  
  -z=, --alpha=  growth constant                         1
  -b=, --beta=   shrink target                           2.0
  -v, --verb     setverb                                 false
  -i=, --item=   setitem                                 ""

==> test/ImplicitDefault.out <==
Usage:
  demo [required&optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                       print this help (generated by cligen)
  --help-syntax                    advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     REQUIRED  setalpha
  -b, --bypass   bool    false     setbypass
  -i=, --item=   string  ""        setitem

==> test/ListDecl.out <==
Usage:
  demo [required&optional-params] [args: int...]
demo entry point with varied, meaningless parameters.
  Options(opt-arg sep :|=|spc):
  -h, --help                      print this help (generated by cligen)
  --help-syntax                   advanced opts: prepend, multi-val, ...
  -a=, --alpha=  float  REQUIRED  setalpha
  -b=, --beta=   float  1.0       setbeta
  -v, --verb     bool   false     setverb

==> test/Mandatory.out <==
Usage:
  demo [required&optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                       print this help (generated by cligen)
  --help-syntax                    advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     REQUIRED  setalpha
  -b=, --beta=   float   2.0       setbeta
  -v, --verb     bool    false     setverb
  -i=, --item=   string  REQUIRED  setitem

==> test/MandatoryNoPos.out <==
Usage:
  demo [required&optional-params] 
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                       print this help (generated by cligen)
  --help-syntax                    advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     REQUIRED  setalpha
  -b=, --beta=   float   2.0       setbeta
  -v, --verb     bool    false     setverb
  -i=, --item=   string  REQUIRED  setitem

==> test/ManualMulti.out <==
Usage:
  ManualMulti demo|show [subcommand-args]

    This is a multiple-dispatch cmd.  Subcommand syntax:

    ManualMulti demo [optional-params] [files: string...]
          This does the demo.
    
    Options:
          -h, --help                    print this help (generated by cligen)
          --help-syntax                 advanced opts: prepend, multi-val, ...
          -a=, --alpha=  int     1      This is a very long parameter help
                                        string which ordinarily should be
                                        auto-wrapped by alignTable into a
                                        multi-line format unless you have eagle
                                        eyes, a gigantic monitor, or maybe a
                                        little bit of both. :-)
          -b=, --beta=   float   2.0    This is more modest, but might still
                                        wrap around once or twice or so.
          -v, --verb     bool    false  on=chatty, off=quiet. 'Nuff said.
          -i=, --item=   string  ""     setitem

    ManualMulti show [optional-params] [paths: string...]
          This shows me something.
    
    Options:
          -h, --help                   print this help (generated by cligen)
          --help-syntax                advanced opts: prepend, multi-val, ...
          -g=, --gamma=  int    1      setgamma
          -i=, --iota=   float  2.0    setiota
          -v, --verb     bool   false  setverb

==> test/MultiFlag.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.
  Options(opt-arg sep :|=|spc):
  -h, --help                  print this help (generated by cligen)
  --help-syntax               advanced opts: prepend, multi-val, ...
  -a, --alpha    bool  true   setalpha
  -b=, --beta=   int   2      setbeta
  -v, --verb     bool  false  setverb

==> test/NoPositional.out <==
Usage:
  demo [optional-params] 
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     1      setalpha
  -b=, --beta=   float   2.0    setbeta
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/NoShort.out <==
Usage:
  demo [optional-params] 
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  --alpha=       int     1      setalpha
  --abc=         float   2.0    setabc
  --aaah         bool    false  setaaah
  --aloha=       string  ""     setaloha

==> test/OneCharParams.out <==
Usage:
  demo [optional-params] [b: string...]
This tests if single character parameters work as expected
  Options(opt-arg sep :|=|spc):
  -h, --help                         print this help (generated by cligen)
  --help-syntax                      advanced opts: prepend, multi-val, ...
  -u=, --u=      int     1           setu
  -c=, --c=      string  "bad name"  setc
  -g=, --g=      string  "ho"        setg

==> test/ParseOnly.out <==
fooParse:
  (paramName: "help", unparsedVal: "", message: "Usage:\n  foo [required&optional-params] [rest: int...]\n  Options(opt-arg sep :|=|spc):\n  -h, --help                    print this help (generated by cligen)\n  --help-syntax                 advanced opts: prepend, multi-val, ...\n  -a=, --alpha=  int  REQUIRED  setalpha\n  -b=, --beta=   int  2         setbeta\n", status: clHelpOnly)
  (paramName: "alpha", unparsedVal: "", message: "Missing alpha", status: clMissing)
would not have called foo
User requested help.  Here you go
Usage:
  foo [required&optional-params] [rest: int...]
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int  REQUIRED  setalpha
  -b=, --beta=   int  2         setbeta


==> test/PerParam.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -z=, --alpha=  int     1      growth constant
  -b=, --beta=   float   2.0    shrink target
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/QualifiedMulti.out <==
Usage:
  QualifiedMulti {subcommand}
where {subcommand} is one of:
  help get put
Run top-level cmd with -h, --help or --help-syntax for top-level help.
Run top-level with subcmd "help" to get *all* helps.
Run any given subcommand with --help to see help for that one.

==> test/QualifiedSym.out <==
Usage:
  get [optional-params] 
  Options(opt-arg sep :|=|spc):
  -h, --help             print this help (generated by cligen)
  --help-syntax          advanced opts: prepend, multi-val, ...
  -a=, --a=      int  1  seta

==> test/ResultInt.out <==
Usage:
  editDistanceAscii [required&optional-params] 
Returns the edit distance between `a` and `b`.

This uses the `Levenshtein`:idx: distance algorithm with only a linear
memory overhead.
  Options(opt-arg sep :|=|spc):
  -h, --help                       print this help (generated by cligen)
  --help-syntax                    advanced opts: prepend, multi-val, ...
  --version      bool    false     print version
  -a=, --a=      string  REQUIRED  seta
  -b=, --b=      string  REQUIRED  setb

==> test/ReturnEmpty.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     1      setalpha
  -b=, --beta=   float   2.0    setbeta
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/ReturnInt.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     1      setalpha
  -b=, --beta=   float   2.0    setbeta
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/ReturnNonInt.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     1      setalpha
  -b=, --beta=   float   2.0    setbeta
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/ReturnNonIntNoAuto.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     1      setalpha
  -b=, --beta=   float   2.0    setbeta
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/ReturnString.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     1      setalpha
  -b=, --beta=   float   2.0    setbeta
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/SemiAutoMulti.out <==
Usage:
  multi [optional-params] [subcmd: string...]
Run command with no parameters for a full help message.
  Options(opt-arg sep :|=|spc):
  -h, --help                 print this help (generated by cligen)
  --help-syntax              advanced opts: prepend, multi-val, ...
  -b=, --beta=   int     1   setbeta
  -i=, --item=   string  ""  setitem

==> test/SeqInt.out <==
Usage:
  demo [optional-params] [args: int...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 3 4" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int     1      setalpha
  -b=, --beta=   char    '\10'  setbeta
  -v, --verb     bool    false  setverb
  -i=, --item=   string  ""     setitem

==> test/Suppress.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                 print this help (generated by cligen)
  --help-syntax              advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int    1    growth constant
  -b=, --beta=   float  2.0  shrink target

==> test/TwoNondefaultedSeq.out <==
TwoNondefaultedSeq.nim(9, 11) template/generic instantiation of `dispatch` from here
cligen.nim(639, 14) template/generic instantiation of `dispatchGen` from here
cligen.nim(138, 16) Warning: cligen only supports one seq param for positional args; using `args`, not `stuff`.  Use `positional` parameter to `dispatch` to override this. [User]
Usage:
  demo [required&optional-params] [args: string...]
demo entry point with varied, meaningless parameters.
  Options(opt-arg sep :|=|spc):
  -h, --help                              print this help (generated by cligen)
  --help-syntax                           advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int            1         setalpha
  -v, --verb     bool           false     setverb
  -s=, --stuff=  array(string)  REQUIRED  append 1 val to stuff

==> test/TwoNondefaultedSeqSwap.out <==
Usage:
  demo [required&optional-params] [ stuffies (1 or more strings) ]
demo entry point with varied, meaningless parameters.
  Options(opt-arg sep :|=|spc):
  -h, --help                              print this help (generated by cligen)
  --help-syntax                           advanced opts: prepend, multi-val, ...
  -a=, --alpha=  int            1         setalpha
  -v, --verb     bool           false     setverb
  --args=        array(string)  REQUIRED  append 1 val to args

==> test/UserDispIdCollide.out <==
Usage:
  demo [optional-params] [args: string...]
This tests if things work when a wrapped user-proc uses identifiers also
used in our generated dispatch proc.
  Options(opt-arg sep :|=|spc):
  -h, --help                           print this help (generated by cligen)
  --help-syntax                        advanced opts: prepend, multi-val, ...
  -u=, --usage=    int     1           setusage
  -c=, --cmdline=  string  "bad name"  setcmdline
  -g=, --getopt=   string  "ho"        setgetopt

==> test/Version.out <==
Usage:
  demo [optional-params] [args: string...]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    print this help (generated by cligen)
  --help-syntax                 advanced opts: prepend, multi-val, ...
  --version      bool    false  print version
  -a=, --alpha=  int     1      setalpha
  -i=, --item=   string  "hi"   setitem
